---
title: "Intro to R"
author: Gibran Hemani
output: 
  pdf_document:
    highlight: tango
---

## Basic calculations

What is the probability of winning the lottery? Assume 49 balls, and 6 balls chosen without replacement. This is how many unique combinations there are.

$$
\frac{49!}
{6!(49-6)!} 
= 
\frac{49 \times 48 \times 47 \times 46 \times 45 \times 44} {6 \times 5 \times 4 \times 3 \times 2 \times 1}
$$

In R it can be calculated like this:

```{r}
49 * 48 * 47 * 46 * 45 * 44 / (6 * 5 * 4 * 3 * 2 * 1)
```

$$
49 \times 48 \times 47 \times 46 \times 45 \times 44 / (6 \times 5 \times 4 \times 3 \times 2 \times 1)
$$

Or we can use built in functions:

```{r}
factorial(49) / (factorial(6) * factorial(49-6))
```

We can find out about the `factorial` function like this:

```{r eval=FALSE}
?factorial
```

We want to store the result from our calculation. This is done like so:

```{r}
lottery <- factorial(49) / (factorial(6) * factorial(49-6))
```

What happens now if you type 

```{r lottery}
lottery
```

This retrieves the stored value. 

What is the probability of winning the lottery if you buy 1 ticket?

```{r}
1 / lottery
```

How about 10 tickets?

```{r}
10 / lottery
```

What is the chance of winning the lottery twice?

```{r}
(1 / lottery)^2
```

In R we can make vectors of numbers instead of dealing in single elements. For example

```{r}
n <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
```

Here the `c()` command tells R to string the numbers 1 to 10 into an array. Another way to do this is:

```{r}
n <- 1:10
```

Now we can calculate the chances of winning for 1, 2, 3, ..., 10 tickets in one command:

```{r}
n / lottery
```

This prints out 10 values, each one is for a different value in `n`.

Notice that we can overwrite a value in a variable, for example

```{r}
n <- 30:40
```

Now type `n` - it has changed because R has replaced the original value with the new value.

It's possible to only extract a single value from an array, using square brackets:

```{r}
n[1]
n[5:8]
```

will extract only the first value of `n` for the first command; or the 5th, 6th, 7th and 8th values in the second command.

How many values are in `n`?

```{r}
length(n)
```

What is the sum of all the values in `n`?

```{r}
sum(n)
```

What is the median value of `n`?

```{r}
median(n)
```

If you type `ls()` you can see your **workspace**. This is the list of all the objects that you have created. Notice that there is one object there called `lottery`, and one called `n`. We can remove objects like this:

```{r}
rm(lottery)
```

Type `ls()` again. Type `lottery`, what happens?


## Data

R comes pre-loaded with some example datasets, one of which we will use here as an example of some basic data manipulation. We will be using the US States Facts and Figures dataset, which is stored as the `state.x77` R object. There is a help file available with background information on this dataset.

The dataset itself is quite large: typing `state.x77` into the R console to look at it results in the output running off the screen.

Instead we can use the `head` function in R to look at the first few rows of the dataset.

```{r}
head(state.x77)
```

or the `tail` function to see the last few rows

```{r}
tail(state.x77)
```

Use the `dim` function to see how many rows and columns it has.

```{r}
dim(state.x77)
```

Type and run the following portion of R code

```{r}
Alaska_Life_Exp <- state.x77[2, 4]
ffrc <- state.x77[1:4, 1:4]
Population <- state.x77[ , 1]
```

This portion of R code uses square brackets to extract data from the `state.x77` R object. Being a table (or matrix) the entries of `state.x77` are indexed by two indices that refer to the row and column. So `state.x77[2, 4]` gives the entry in the second row and fourth column (the Alaskan life expectancy, 69.05 years). Also s`tate.x77[1:4, 1:4]` gives the first four rows and columns of the table. Finally, `state.x77[ , 1]` gives the first column (the population of all the states). Note that the first row displayed in the R console gives the column headings and the first column displayed in the R console gives the row headings. 

Can you use this data to calculate the total area of the US? The total population?


## Plotting

What is the relationship between income and literacy amongst the US states? What is the correlation?

```{r}
cor(state.x77[, "Income"], state.x77[, "Illiteracy"])
```

There seems to be an inverse proportional relationship. We can visualise this:

```{r}
plot(Income ~ Illiteracy, state.x77)
```

What is the distribution of Income?

```{r}
hist(state.x77[, "Income"])
```

You can save a plot like this:

```{r eval=FALSE}
pdf("test.pdf")
hist(state.x77[, "Income"])
dev.off()
```


## Reading and writing data

It is important to be able to get data into R, and back out again. Here we will look at two examples - Excel files, and Stata files.


### Excel

In Excel it is possible to save spreadsheet data as `.csv` files - "comma separated values". R can read `.csv` files using the `read.csv()` function. Have a look at the documentation:

```{r eval=FALSE}
?read.csv
```

Notice that there are a lot of options here to be as flexible as possible for reading in data that has been formatted in different ways. The default options for `read.csv` are usually suitable for reading in a file that has just been experted from Excel.

Let's try reading in a csv file...

```{r}
phen <- read.csv("../data/example_data/phen.csv")
```

What does this data look like?

```{r}
head(phen)
```

What are the dimensions?

```{r}
dim(phen)
```


### Stata

We can also read in files that are in Stata format. But first we need to install a library that will provide the necessary functions.

```{r eval=FALSE}
install.packages("readstata13")
```

Once the library is installed we can load it

```{r}
library(readstata13)
```

And now we can use the functions that are provided by this package. Let's read in a Stata file:

```{r}
phen <- read.dta13("../data/example_data/phen.dta")
```


## Monty Hall problem

Suppose you're on a game show, and you're given the choice of three doors: Behind one door is a car; behind the others, goats. You pick a door, say No. 1, and the host, who knows what's behind the doors, opens another door, say No. 3, which has a goat. He then says to you, "Do you want to pick door No. 2?" Is it to your advantage to switch your choice?

Let's simulate this scenario to check!

We will make a function which simulates one game:

```{r}
monty <- function()
{
    doors <- 1:3 # initialize the doors behind one of which is a good prize
    win <- 0 # to keep track of number of wins
 
    prize <- sample(1:3, 1) # randomize which door has the good prize
    guess <- sample(1:3, 1) # guess a door at random
 
    ## Reveal one of the doors you didn't pick which has a goat
    if(prize != guess) {
        reveal <- doors[-c(prize,guess)]
    } else {
        reveal <- sample(doors[-c(prize,guess)], 1)
    }

    ## Stay with your initial guess or switch
    switch_guess <- doors[-c(reveal,guess)]
    stay_guess <- guess        

    ## Did you win?
    win <- ifelse(switch_guess == prize, "switch", "stay")

    ## return results
    result <- data.frame(
        prize = prize,
        guess = guess,
        win = win,
        stringsAsFactors=FALSE
    )
    return(result)
}
```

Here's how it works:

```{r}
monty()
```


Let's see what happens if we do this multiple times...

```{r message=FALSE}
n_simulations <- 10
all_results <- list()
for(i in 1:n_simulations)
{
    message(i)
    all_results[[i]] <- monty()
}
all_results <- do.call(rbind, all_results)
```

Let's see what the results look like! We want to know the proportion of wins for the 'stay' strategy, and the proportion of wins for the 'switch' strategy

```{r}
table(all_results$win)
```

Perhaps this was just chance? Let's plot what it looks like. We will need to install a new library, `ggplot2`. This library is fantastic for making fairly complex plots very quickly.

```{r eval=FALSE}
install.packages("ggplot2")
```

```{r }
library(ggplot2)
```

Here's the plot

```{r}
# Label the simulations
all_results$simulation <- 1:n_simulations

# Get the cumulative sum of wins
all_results$cumulative <- NA

stay_index <- all_results$win == "stay"
all_results$cumulative[stay_index] <- 1:sum(stay_index)

switch_index <- all_results$win == "switch"
all_results$cumulative[switch_index] <- 1:sum(switch_index)

# Make the plot
ggplot(all_results, aes(x=simulation, y=cumulative)) +
geom_point(aes(colour=win)) +
geom_line(aes(colour=win)) +
labs(y="Cumulative sum of successes", x="Number of simulations")
```

Run the simulations again, but this time do 1000 simulations instead of just 10. Now what is the result?


## Packages

We have already installed two packages. For the remainder of the course we are going to need some more. There are three main sources to get packages

- **CRAN** This is the main R package repository. It has over 8000 packages for a huge variaty of things. [https://cran.r-project.org](https://cran.r-project.org)
- **Bioconductor**  This is another repository which has packages that are mostly focused on genomic data. [http://bioconductor.org](http://bioconductor.org)
- **GitHub** A lot of people publish packages, or updates to packages, on GitHub before they are released to the CRAN or Bioconductor.

We need to install the following packages from CRAN:

```{r eval=FALSE}
install.packages("CpGassoc")
install.packages("GenABEL")
```

And the following package from Bioconductor:

```{r eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite("minfi")
```
